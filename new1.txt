@1.开始准备工作 （红色代表工作区未与stage同步，绿色则代表已同步）
mkdir 例子        # 创建一个repository（仓库、版本库）,其实目前只是一个名为“例子”的文件夹，在github的文件夹中能看见
cd 例子         # 指向（打开到）当前文件
pwd           # 展示文件路径

git init      # 命令把这个目录变成Git可以管理的仓库


@2.创建并上传文件
先创建一个文件“readme”并保存到“例子”目录下（子目录也行）
git add readme.文件后缀名（如.txt）             # 把文件添加到仓库
... 可以多次添加不同文件
git commit -m '最好是注释，提醒内容等'           # 把文件提交到仓库，相当于确定之前的添加文件的操作


@3.继续上次工作
git status     # 可以让我们时刻掌握仓库当前的状态
git diff       # 查看具体变化
每次修改完要养成add + commit 的保存好习惯，最后可用status查看确认

退回前准备：
git log            # 显示从最近到最远的提交日志,如果信息太多，可加上 --pretty=oneline
                   # 看到的一大串类似3628164...882e1e0的是commit_id（版本号）
				   # Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，
				     也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），
				     上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。


@4.退回版本
git reset --hard commit_id
git reset --hard HEAD^        # 这里是退回到上一个版本，执行完就能看到文件已被更改
git reset --hard 3628164        # 这里是跳到指定的某个版本（ID为3628164的），可以是未来的（或是过去的？）

如果ID丢失（关了shell窗口），可以用：
git reflog      # 查看历史命令并显示ID


@5.管理修改 （每次commit后，stage区都会被清空。）
git diff HEAD -- <file>    # 查看工作区和版本库里面最新版本的区别


@6.撤销修改  （让这个文件回到最近一次git commit或git add时的状态）
git checkout -- <file>       # 把file文件在工作区的修改全部撤销，这里有两种情况:
                             # file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；
                             # file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
						 
git reset HEAD <file>        # git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。

小结: 

场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- <file>。

场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，
       就回到了场景1，第二步按场景1操作。

场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。


@7.删除文件
rm <file>    # 执行删除工作区的<file>
git rm <file>        # 如果已进行上一步操作，则相当于把操作add到stage；若无，把删除操作进行并同步到stage，可不必要进行上一步。
git commit           # 确认操作，在这步之前可用reset + checkout退回
